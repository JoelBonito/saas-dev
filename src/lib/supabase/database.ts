import { supabase } from './client'

// ==================== CONVERSATIONS ====================

export interface Conversation {
  id: string
  project_id: string
  title: string
  created_at: string
  updated_at: string
}

export interface Message {
  id: string
  conversation_id: string
  role: 'user' | 'assistant' | 'system'
  content: string
  tokens_used?: number
  model_used?: string
  metadata?: Record<string, any>
  created_at: string
}

export interface GeneratedFile {
  id: string
  project_id: string
  message_id?: string
  file_path: string
  file_name: string
  file_type: string
  content: string
  version: number
  status: 'active' | 'modified' | 'deleted'
  created_at: string
  updated_at: string
}

export interface ApiUsage {
  id: string
  user_id: string
  project_id?: string
  message_id?: string
  tokens_input: number
  tokens_output: number
  tokens_total: number
  cost_usd?: number
  model_used: string
  created_at: string
}

/**
 * Get all conversations for a project
 */
export async function getConversations(projectId: string): Promise<Conversation[]> {
  const { data, error } = await supabase
    .from('conversations')
    .select('*')
    .eq('project_id', projectId)
    .order('updated_at', { ascending: false })

  if (error) {
    console.error('Error fetching conversations:', error)
    throw error
  }

  return data || []
}

/**
 * Get a single conversation by ID
 */
export async function getConversation(conversationId: string): Promise<Conversation | null> {
  const { data, error } = await supabase
    .from('conversations')
    .select('*')
    .eq('id', conversationId)
    .single()

  if (error) {
    console.error('Error fetching conversation:', error)
    return null
  }

  return data
}

/**
 * Create a new conversation
 */
export async function createConversation(
  projectId: string,
  title: string
): Promise<Conversation | null> {
  const { data, error } = await supabase
    .from('conversations')
    .insert({
      project_id: projectId,
      title: title.substring(0, 100), // Limit title length
    })
    .select()
    .single()

  if (error) {
    console.error('Error creating conversation:', error)
    throw error
  }

  return data
}

/**
 * Update conversation title
 */
export async function updateConversationTitle(
  conversationId: string,
  title: string
): Promise<void> {
  const { error } = await supabase
    .from('conversations')
    .update({ title, updated_at: new Date().toISOString() })
    .eq('id', conversationId)

  if (error) {
    console.error('Error updating conversation:', error)
    throw error
  }
}

/**
 * Delete a conversation
 */
export async function deleteConversation(conversationId: string): Promise<void> {
  const { error } = await supabase
    .from('conversations')
    .delete()
    .eq('id', conversationId)

  if (error) {
    console.error('Error deleting conversation:', error)
    throw error
  }
}

// ==================== MESSAGES ====================

/**
 * Get all messages for a conversation
 */
export async function getMessages(conversationId: string): Promise<Message[]> {
  const { data, error } = await supabase
    .from('messages')
    .select('*')
    .eq('conversation_id', conversationId)
    .order('created_at', { ascending: true })

  if (error) {
    console.error('Error fetching messages:', error)
    throw error
  }

  return data || []
}

/**
 * Save a message (user or assistant)
 */
export async function saveMessage(
  conversationId: string,
  role: 'user' | 'assistant' | 'system',
  content: string,
  tokensUsed?: number,
  modelUsed?: string,
  metadata?: Record<string, any>
): Promise<Message | null> {
  const { data, error } = await supabase
    .from('messages')
    .insert({
      conversation_id: conversationId,
      role,
      content,
      tokens_used: tokensUsed || 0,
      model_used: modelUsed,
      metadata: metadata || {},
    })
    .select()
    .single()

  if (error) {
    console.error('Error saving message:', error)
    throw error
  }

  return data
}

// ==================== FILES ====================

/**
 * Get all files for a project
 */
export async function getProjectFiles(projectId: string): Promise<GeneratedFile[]> {
  const { data, error } = await supabase
    .from('files')
    .select('*')
    .eq('project_id', projectId)
    .eq('status', 'active')
    .order('file_path', { ascending: true })

  if (error) {
    console.error('Error fetching files:', error)
    throw error
  }

  return data || []
}

/**
 * Get files generated by a specific message
 */
export async function getMessageFiles(messageId: string): Promise<GeneratedFile[]> {
  const { data, error } = await supabase
    .from('files')
    .select('*')
    .eq('message_id', messageId)
    .eq('status', 'active')
    .order('file_path', { ascending: true })

  if (error) {
    console.error('Error fetching message files:', error)
    throw error
  }

  return data || []
}

/**
 * Save a generated file
 */
export async function saveFile(
  projectId: string,
  filePath: string,
  fileName: string,
  fileType: string,
  content: string,
  messageId?: string
): Promise<GeneratedFile | null> {
  // Check if file already exists
  const { data: existingFile } = await supabase
    .from('files')
    .select('*')
    .eq('project_id', projectId)
    .eq('file_path', filePath)
    .eq('status', 'active')
    .single()

  if (existingFile) {
    // Update existing file (increment version)
    const { data, error } = await supabase
      .from('files')
      .update({
        content,
        version: existingFile.version + 1,
        updated_at: new Date().toISOString(),
        message_id: messageId,
      })
      .eq('id', existingFile.id)
      .select()
      .single()

    if (error) {
      console.error('Error updating file:', error)
      throw error
    }

    return data
  } else {
    // Create new file
    const { data, error } = await supabase
      .from('files')
      .insert({
        project_id: projectId,
        message_id: messageId,
        file_path: filePath,
        file_name: fileName,
        file_type: fileType,
        content,
        version: 1,
        status: 'active',
      })
      .select()
      .single()

    if (error) {
      console.error('Error saving file:', error)
      throw error
    }

    return data
  }
}

/**
 * Delete a file (soft delete)
 */
export async function deleteFile(fileId: string): Promise<void> {
  const { error } = await supabase
    .from('files')
    .update({
      status: 'deleted',
      updated_at: new Date().toISOString(),
    })
    .eq('id', fileId)

  if (error) {
    console.error('Error deleting file:', error)
    throw error
  }
}

// ==================== API USAGE ====================

/**
 * Get API usage for a user
 */
export async function getApiUsage(
  userId: string,
  projectId?: string,
  limit = 100
): Promise<ApiUsage[]> {
  let query = supabase
    .from('api_usage')
    .select('*')
    .eq('user_id', userId)
    .order('created_at', { ascending: false })
    .limit(limit)

  if (projectId) {
    query = query.eq('project_id', projectId)
  }

  const { data, error } = await query

  if (error) {
    console.error('Error fetching API usage:', error)
    throw error
  }

  return data || []
}

/**
 * Get total API usage stats for a user
 */
export async function getApiUsageStats(
  userId: string,
  projectId?: string
): Promise<{
  total_tokens: number
  total_cost: number
  message_count: number
}> {
  let query = supabase
    .from('api_usage')
    .select('tokens_total, cost_usd')
    .eq('user_id', userId)

  if (projectId) {
    query = query.eq('project_id', projectId)
  }

  const { data, error } = await query

  if (error) {
    console.error('Error fetching API usage stats:', error)
    throw error
  }

  const stats = data?.reduce(
    (acc, usage) => ({
      total_tokens: acc.total_tokens + usage.tokens_total,
      total_cost: acc.total_cost + (usage.cost_usd || 0),
      message_count: acc.message_count + 1,
    }),
    { total_tokens: 0, total_cost: 0, message_count: 0 }
  )

  return stats || { total_tokens: 0, total_cost: 0, message_count: 0 }
}

// ==================== CODE GENERATIONS ====================

export interface CodeGeneration {
  id: string
  project_id: string
  message_id: string
  prompt: string
  generated_files: Record<string, any>
  success: boolean
  error_message?: string
  tokens_consumed: number
  generation_time_ms?: number
  created_at: string
}

/**
 * Save a code generation record
 */
export async function saveCodeGeneration(
  projectId: string,
  messageId: string,
  prompt: string,
  generatedFiles: Record<string, any>,
  success: boolean,
  tokensConsumed: number,
  errorMessage?: string,
  generationTimeMs?: number
): Promise<CodeGeneration | null> {
  const { data, error } = await supabase
    .from('code_generations')
    .insert({
      project_id: projectId,
      message_id: messageId,
      prompt,
      generated_files: generatedFiles,
      success,
      error_message: errorMessage,
      tokens_consumed: tokensConsumed,
      generation_time_ms: generationTimeMs,
    })
    .select()
    .single()

  if (error) {
    console.error('Error saving code generation:', error)
    throw error
  }

  return data
}

/**
 * Get code generations for a project
 */
export async function getCodeGenerations(projectId: string): Promise<CodeGeneration[]> {
  const { data, error } = await supabase
    .from('code_generations')
    .select('*')
    .eq('project_id', projectId)
    .order('created_at', { ascending: false })

  if (error) {
    console.error('Error fetching code generations:', error)
    throw error
  }

  return data || []
}
